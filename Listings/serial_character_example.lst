C51 COMPILER V9.60.7.0   SERIAL_CHARACTER_EXAMPLE                                          09/13/2023 17:28:08 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE SERIAL_CHARACTER_EXAMPLE
OBJECT MODULE PLACED IN .\Objects\serial_character_example.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE serial_character_example.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND P
                    -RINT(.\Listings\serial_character_example.lst) TABS(2) OBJECT(.\Objects\serial_character_example.obj)

line level    source

   1          #include <at89x52.h>
   2          #include <string.h>
   3          #include <math.h>
   4          
   5          #define DAC P0
   6          #define LCD P2
   7          #define EN P3_7 // LCD enable
   8          #define RS P3_6 // LCD instruction or dataa
   9          
  10          // Prototipos das fun??es
  11          void playComposer();
  12          void reset();
  13          void nop();
  14          void timer_config();
  15          void serial_config();
  16          void LCD_config();
  17          void INT_config(); // Configura interrup??es
  18          void aponta_line1(); // Linha 1 do LCD
  19          void aponta_line2();
  20          void write_lcd_string(char *str);
  21          void WR_CMD();
  22          void WR_CHAR();
  23          void isr_serial(void); // Interruption
  24          void delay_notes(unsigned char index);
  25          void delay_us(int us);
  26          void delay_ms(int ms);
  27          void play_period_note(unsigned char index);
  28          void play_note(unsigned char note, unsigned int rep_of_250ms);
  29          void testNotes();
  30          void timer_config();
  31          
  32          // Variaveis globais
  33          char notes[40];
  34          char char_temp;
  35          bit flag = 0;
  36          
  37          unsigned int count = 0;
  38          unsigned int countNotes = 0;
  39          
  40          unsigned char state = 0;
  41          
  42          unsigned char note;
  43          // char MSG1[] = "Welcome...";
  44          const char code MSG2[] = "Choose mode...";
  45          const char code MSG3[] = "1 Piano 2 Compos";
  46          const char code MSG4[] = "-- PIANO MODE --";
  47          const char code MSG5[] = " Play any key ";
  48          const char code MSG6[] = "COMPOSER MODE";
  49          const char code MSG7[] = "Enter with notes and its time";
  50          const unsigned char code f_Htimer[] = {
  51            0xc4, 0xca, 0xd0, 0xd3, 0xd8, 0xdc, 0xe0, 0xe2, 0xe5, 0xe8, 0xe9, 0xec, 0xee, 0xf0, 0xf1, 0xf2, 0xf4, 0xf
             -4, 0xf6, 0xf7, 0xf8, 0xf8, 0xf9, 0xfa, 0xfa, 0xfb, 0xfb, 0xfc, 0xfc};
  52          const unsigned char code f_Ltimer[] = {
  53            0x45, 0xcc, 0x98, 0x41, 0x24, 0x7d, 0x5e, 0x24, 0x66, 0x4d, 0xa1, 0x12, 0x3f, 0x2e, 0x12, 0xb3, 0x26, 0xd
C51 COMPILER V9.60.7.0   SERIAL_CHARACTER_EXAMPLE                                          09/13/2023 17:28:08 PAGE 2   

             -0, 0x09, 0x1f, 0x17, 0x89, 0x59, 0x13, 0x68, 0x04, 0x90, 0x0c, 0x44};
  54          const unsigned char code reps_notes_to_250ms[] = {
  55            8, 9, 10, 11, 12, 14, 15, 16, 18, 21, 22, 25, 28, 31, 33, 37, 41, 44, 49, 55, 62, 65, 73, 82, 87, 98, 110
             -, 123, 131
  56          };
  57          
  58          
  59          
  60          // Funcao principal
  61          void main(void){
  62   1        DAC = 0;
  63   1        
  64   1        timer_config();
  65   1        serial_config();
  66   1        LCD_config();
  67   1        INT_config();
  68   1      
  69   1        while (1){ //ações que acontecem em cada estado
  70   2          
  71   2          if (state == 3){ // Tocar Note e voltar para espera de outra nota
  72   3      
  73   3            play_note(char_temp, 1);
  74   3            if(!flag){
  75   4              state = 2;
  76   4            }
  77   3            //flag = 1, continua no estado 3 (outra nota para executar)
  78   3            flag = 0;
  79   3          }
  80   2          else if (state == 2){ // Espera de outra nota
  81   3            flag = 0;
  82   3          }
  83   2          else if(state == 0){ // Carrega msg menu
  84   3            aponta_line1();
  85   3            write_lcd_string(MSG2);
  86   3            aponta_line2();
  87   3            write_lcd_string(MSG3);
  88   3            state = 1;
  89   3          }
  90   2          else if(state == 1){ // Menu
  91   3            P0_0 = 1;
  92   3          }
  93   2          else if (state == 100){ //transicao msg Piano mode 
  94   3            P0_2 = 1;
  95   3            P0_1 = 0;
  96   3            P0_0 = 0;
  97   3            aponta_line1();
  98   3            write_lcd_string(MSG4);
  99   3            aponta_line2();
 100   3            write_lcd_string(MSG5);
 101   3            state = 2;
 102   3          }
 103   2          else if (state == 101){ //transicao msg Composer mode
 104   3            P0_2 = 1;
 105   3            P0_1 = 0;
 106   3            P0_0 = 1;
 107   3            aponta_line1();
 108   3            write_lcd_string(MSG6);
 109   3            aponta_line2();
 110   3            write_lcd_string(MSG7);
 111   3            aponta_line1();
 112   3            write_lcd_string(MSG6);
 113   3            state = 50;
C51 COMPILER V9.60.7.0   SERIAL_CHARACTER_EXAMPLE                                          09/13/2023 17:28:08 PAGE 3   

 114   3          }
 115   2          else if (state == 50){ // Espera ISR_serial recolher musica
 116   3          }
 117   2          else if (state == 51){ // Toca composicao e volta para state 101
 118   3      
 119   3            playComposer();
 120   3            state = 50; 
 121   3          }
 122   2          else if (state == 255){ // Resetar
 123   3            EA = 0;
 124   3            reset();
 125   3            state = 0;
 126   3            EA = 1;
 127   3          }
 128   2        }
 129   1          
 130   1      }
 131          
 132          // Funcao para atender a interrupcao serial
 133          void isr_serial(void) interrupt 4 { 
 134   1        
 135   1        TF0 = 1;
 136   1        TR0 = 0;
 137   1        char_temp = SBUF;
 138   1        
 139   1        if (char_temp == 27){ //Tecla ESC. Reset
 140   2          state = 255;
 141   2        }
 142   1        else if (state == 2){ // Piano mode
 143   2          state = 3;
 144   2        }
 145   1        else if (state == 3){ // Piano mode
 146   2          flag = 1;
 147   2        }
 148   1        else if (state == 1) { // Menu mode
 149   2          P0_7 = 0;
 150   2          if (char_temp == '1'){  //MSG Piano Mode transition
 151   3            state = 100;
 152   3          }
 153   2          else if (char_temp == '2'){ // MSG Composer Mode transition
 154   3            state = 101;
 155   3          }
 156   2        }
 157   1        else if (state == 50){ // Composer mode
 158   2      
 159   2          if (countNotes == 40 || char_temp == 13){
 160   3            countNotes = 0;
 161   3            state = 51;
 162   3          }
 163   2          else{
 164   3            notes[countNotes] = char_temp;
 165   3            countNotes++;
 166   3          }
 167   2        }
 168   1      
 169   1        RI = 0; // Limpa a flag de interrupcao serial
 170   1      }
 171          
 172          // Funcao para atender a interrupcao timer 1
 173          void isr_tf1(void) interrupt 3 {
 174   1        //DAC = ~DAC; //Quando o timer estoura
 175   1      }
C51 COMPILER V9.60.7.0   SERIAL_CHARACTER_EXAMPLE                                          09/13/2023 17:28:08 PAGE 4   

 176          
 177          void play_period_note(unsigned char index){
 178   1      
 179   1        //DAC = 0;
 180   1        delay_notes(index);
 181   1        DAC = ~DAC;
 182   1        delay_notes(index);
 183   1        DAC = ~DAC;
 184   1      }
 185          
 186          void play_note(unsigned char note, unsigned int rep_of_250ms){
 187   1      
 188   1        int note_number = -1;
 189   1        switch (note) {
 190   2          case 'q':
 191   2            note_number = 0;
 192   2            break;
 193   2          case 'w':
 194   2            note_number = 1;
 195   2            break;
 196   2          case 'e':
 197   2            note_number = 2;
 198   2            break;
 199   2          case 'r':
 200   2            note_number = 3;
 201   2            break;
 202   2          case 't':
 203   2            note_number = 4;
 204   2            break;
 205   2          case 'y':
 206   2            note_number = 5;
 207   2            break;
 208   2          case 'u':
 209   2            note_number = 6;
 210   2            break;
 211   2          case 'i':
 212   2            note_number = 7;
 213   2            break;
 214   2          case 'o':
 215   2            note_number = 8;
 216   2            break;
 217   2          case 'p':
 218   2            note_number = 9;
 219   2            break;
 220   2          case 'a':
 221   2            note_number = 10;
 222   2            break;
 223   2          case 's':
 224   2            note_number = 11;
 225   2            break;
 226   2          case 'd':
 227   2            note_number = 12;
 228   2            break;
 229   2          case 'f':
 230   2            note_number = 13;
 231   2            break;
 232   2          case 'g':
 233   2            note_number = 14;
 234   2            break;
 235   2          case 'h':
 236   2            note_number = 15;
 237   2            break;
C51 COMPILER V9.60.7.0   SERIAL_CHARACTER_EXAMPLE                                          09/13/2023 17:28:08 PAGE 5   

 238   2          case 'j':
 239   2            note_number = 16;
 240   2            break;
 241   2          case 'k':
 242   2            note_number = 17;
 243   2            break;
 244   2          case 'l':
 245   2            note_number = 18;
 246   2            break;
 247   2          case 199:
 248   2            note_number = 19;
 249   2            break;
 250   2          case 'z':
 251   2            note_number = 20;
 252   2            break;
 253   2          case 'x':
 254   2            note_number = 21;
 255   2            break;
 256   2          case 'c':
 257   2            note_number = 22;
 258   2            break;
 259   2          case 'v':
 260   2            note_number = 23;
 261   2            break;
 262   2          case 'b':
 263   2            note_number = 24;
 264   2            break;
 265   2          case 'n':
 266   2            note_number = 25;
 267   2            break;
 268   2          case 'm':
 269   2            note_number = 26;
 270   2            break;
 271   2          case ',':
 272   2            note_number = 27;
 273   2            break;
 274   2          case '.':
 275   2            note_number = 28;
 276   2            break;
 277   2          default:
 278   2            // Handle the case where note does not match any of the above values
 279   2            break;
 280   2        }
 281   1      
 282   1        if (note_number >= 0){
 283   2          unsigned int temp;
 284   2          temp = reps_notes_to_250ms[note_number] * rep_of_250ms;
 285   2          for (; temp > 0; --temp){
 286   3            play_period_note(note_number);
 287   3          }
 288   2        }
 289   1      }
 290          
 291          void playComposer(){
 292   1        char *str = notes;
 293   1        char note;
 294   1        char time;
 295   1      
 296   1        while (*str){
 297   2          note = *str++;
 298   2          time = *str++;
 299   2          play_note(note, time-48);
C51 COMPILER V9.60.7.0   SERIAL_CHARACTER_EXAMPLE                                          09/13/2023 17:28:08 PAGE 6   

 300   2        }
 301   1      }
 302          
 303          void testNotes(){
 304   1        LCD = 'q';
 305   1        WR_CHAR();
 306   1        play_note('q', 10);
 307   1        delay_ms(1000);
 308   1        
 309   1        LCD = 'w';
 310   1        WR_CHAR();
 311   1        play_note('w', 10);
 312   1        delay_ms(1000);
 313   1      
 314   1        LCD = 'e';
 315   1        WR_CHAR();
 316   1        play_note('e', 10);
 317   1        delay_ms(1000);
 318   1      
 319   1        LCD = 'r';
 320   1        WR_CHAR();
 321   1        play_note('r', 10);
 322   1        delay_ms(1000);
 323   1      
 324   1        LCD = 't';
 325   1        WR_CHAR();
 326   1        play_note('t', 10);
 327   1        delay_ms(1000);
 328   1      
 329   1        LCD = 'y';
 330   1        WR_CHAR();
 331   1        play_note('y', 10);
 332   1        delay_ms(1000);
 333   1      
 334   1        LCD = 'u';
 335   1        WR_CHAR();
 336   1        play_note('u', 10);
 337   1        delay_ms(1000);
 338   1        
 339   1        LCD = 'i';
 340   1        WR_CHAR();
 341   1        play_note('i', 10);
 342   1        delay_ms(1000);
 343   1      
 344   1        LCD = 'o';
 345   1        WR_CHAR();
 346   1        play_note('o', 10);
 347   1        delay_ms(1000);
 348   1      
 349   1        LCD = 'p';
 350   1        WR_CHAR();
 351   1        play_note('p', 10);
 352   1        delay_ms(1000);
 353   1      
 354   1        LCD = 'a';
 355   1        WR_CHAR();
 356   1        play_note('a', 10);
 357   1        delay_ms(1000);
 358   1      
 359   1        LCD = 's';
 360   1        WR_CHAR();
 361   1        play_note('s', 10);
C51 COMPILER V9.60.7.0   SERIAL_CHARACTER_EXAMPLE                                          09/13/2023 17:28:08 PAGE 7   

 362   1        delay_ms(1000);
 363   1      
 364   1        LCD = 'd';
 365   1        WR_CHAR();
 366   1        play_note('d', 10);
 367   1        delay_ms(1000);
 368   1      
 369   1        LCD = 'f';
 370   1        WR_CHAR();
 371   1        play_note('f', 10);
 372   1        delay_ms(1000);
 373   1      
 374   1        LCD = 'g';
 375   1        WR_CHAR();
 376   1        play_note('g', 10);
 377   1        delay_ms(1000);
 378   1      
 379   1        LCD = 'h';
 380   1        WR_CHAR();
 381   1        play_note('h', 10);
 382   1        delay_ms(1000);
 383   1      
 384   1        LCD = 'j';
 385   1        WR_CHAR();
 386   1        play_note('j', 10);
 387   1        delay_ms(1000);
 388   1      
 389   1        LCD = 'k';
 390   1        WR_CHAR();
 391   1        play_note('k', 10);
 392   1        delay_ms(1000);
 393   1        
 394   1        LCD = 'l';
 395   1        WR_CHAR();
 396   1        play_note('l', 10);
 397   1        delay_ms(1000);
 398   1      
 399   1        LCD = 199;
 400   1        WR_CHAR();
 401   1        play_note(199, 10);
 402   1        delay_ms(1000);
 403   1      
 404   1        LCD = 'z';
 405   1        WR_CHAR();
 406   1        play_note('z', 10);
 407   1        delay_ms(1000);
 408   1      
 409   1        LCD = 'x';
 410   1        WR_CHAR();
 411   1        play_note('x', 10);
 412   1        delay_ms(1000);
 413   1      
 414   1        LCD = 'c';
 415   1        WR_CHAR();
 416   1        play_note('c', 10);
 417   1        delay_ms(1000);
 418   1      
 419   1        LCD = 'v';
 420   1        WR_CHAR();
 421   1        play_note('v', 10);
 422   1        delay_ms(1000);
 423   1      
C51 COMPILER V9.60.7.0   SERIAL_CHARACTER_EXAMPLE                                          09/13/2023 17:28:08 PAGE 8   

 424   1        LCD = 'b';
 425   1        WR_CHAR();
 426   1        play_note('b', 10);
 427   1        delay_ms(1000);
 428   1      
 429   1        LCD = 'n';
 430   1        WR_CHAR();
 431   1        play_note('n', 10);
 432   1        delay_ms(1000);
 433   1      
 434   1        LCD = 'm';
 435   1        WR_CHAR();
 436   1        play_note('m', 10);
 437   1        delay_ms(1000);
 438   1      
 439   1        LCD = '.';
 440   1        WR_CHAR();
 441   1        play_note('.', 10);
 442   1        delay_ms(1000);
 443   1      
 444   1        LCD = ';';
 445   1        WR_CHAR();
 446   1        play_note(';', 10);
 447   1        delay_ms(1000);
 448   1      }
 449          // ---------------------- Delays ---------------------------
 450          
 451          void delay_notes(unsigned char index){
 452   1        TMOD |= 0x01;
 453   1        TH0 = f_Htimer[index];
 454   1        TL0 = f_Ltimer[index];
 455   1        TR0 = 1;
 456   1        while (!TF0);
 457   1        TF0 = 0;
 458   1        TR0 = 0;
 459   1      }
 460          
 461          void delay_ms(int ms){
 462   1        TMOD |= 0x01;
 463   1        while (ms){
 464   2          TL0 = 0x65;
 465   2          TH0 = 0xFC;
 466   2          TR0 = 1;
 467   2          while (!TF0);
 468   2          TF0 = 0;
 469   2          TR0 = 0;
 470   2          ms--;
 471   2        }
 472   1      }
 473          
 474          void delay_us(int us){
 475   1        int i;
 476   1        for(i = 0; i < us; ++i){
 477   2        }
 478   1      }
 479          
 480          void nop(){}
 481          
 482          // -- LCD functions
 483          
 484          void aponta_line1(){
 485   1      
C51 COMPILER V9.60.7.0   SERIAL_CHARACTER_EXAMPLE                                          09/13/2023 17:28:08 PAGE 9   

 486   1        LCD = 0x01; // Limpa o display.
 487   1        WR_CMD();
 488   1        LCD = 0x80; // Cursor para a primeira linha
 489   1        WR_CMD();
 490   1      }
 491          
 492          void aponta_line2(){
 493   1      
 494   1        LCD = 0xC0; // Cursor para a segunda linha
 495   1        WR_CMD();
 496   1        LCD = 0x0F; // Cursor Piscando
 497   1        WR_CMD();
 498   1      }
 499          
 500          void WR_CMD(){
 501   1      
 502   1        RS = 0;
 503   1        nop();
 504   1        EN = 1;
 505   1        delay_us(5);
 506   1        EN = 0;
 507   1        delay_ms(5);
 508   1      }
 509          
 510          void WR_CHAR(){
 511   1      
 512   1        RS = 1;
 513   1        nop();
 514   1        EN = 1;
 515   1        delay_us(5);
 516   1        EN = 0;
 517   1        delay_ms(50);
 518   1      }
 519          
 520          // Funcao para escrever uma string na LCD
 521          void write_lcd_string(char *str){
 522   1      
 523   1        count = 0;
 524   1        while (*str){
 525   2          LCD = (unsigned char)*str++;
 526   2          WR_CHAR();
 527   2          count++;
 528   2          if (count == 16){ // Liga o scroll
 529   3            LCD = 0x07;
 530   3            WR_CMD();
 531   3          }
 532   2        }
 533   1        LCD = 0x06; // Deslocamento do cursor E->D.
 534   1        WR_CMD();
 535   1      }
 536          
 537          //---------------------------- Configura ----------------------------------------------------
 538          
 539          void reset(){
 540   1        count = 0;
 541   1        LCD_config();
 542   1        aponta_line1();
 543   1        write_lcd_string(MSG2);
 544   1        aponta_line2();
 545   1        write_lcd_string(MSG3);
 546   1        state = 0;
 547   1      }
C51 COMPILER V9.60.7.0   SERIAL_CHARACTER_EXAMPLE                                          09/13/2023 17:28:08 PAGE 10  

 548          
 549          void serial_config(){
 550   1        PCON = 0x80; // SMOD = 1.
 551   1        SCON = 0x50; // Modo 1, recep??o habilitada (REN = 1).
 552   1      }
 553          
 554          void LCD_config(){
 555   1        LCD = 0x38; // Define a matriz 5x7 pontos.
 556   1        WR_CMD();
 557   1        LCD = 0x06; // Deslocamento do cursor E->D.
 558   1        WR_CMD();
 559   1        LCD = 0x0E; // Cursor fixo.
 560   1        WR_CMD();
 561   1        LCD = 0x01; // Limpa o display.
 562   1        WR_CMD();
 563   1        LCD = 0x02; // Vai para a primeira linha (opcional).
 564   1        WR_CMD();
 565   1      }
 566          
 567          void INT_config(){
 568   1        //serial
 569   1        IE = 0x90;
 570   1      }
 571          
 572          void timer_config(){
 573   1        TMOD = 0x20;    // Configura T/C 1 em modo 8 bits com recarga.
 574   1          TH1 = 253;
 575   1          TL1 = 253;
 576   1          TR1 = 1;
 577   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1694    ----
   CONSTANT SIZE    =    195    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     47      15
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
